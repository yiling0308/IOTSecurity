> A1:2017-Injection
- Scenario #1: An application uses untrusted data in the construction of the following vulnerable SQL call:

        String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";

- Scenario #2: Similarly, an application’s blind trust in frameworks may result in queries that are still vulnerable, (e.g. Hibernate Query Language (HQL)):

        Query HQLQuery = session.createQuery("FROM accounts WHERE custID='" + request.getParameter("id") + "'");

- In both cases, the attacker modifies the ‘id’ parameter value in their browser to send: ' or '1'='1. For example:

        http://example.com/app/accountView?id=' or '1'='1
This changes the meaning of both queries to return all the records from the accounts table. More dangerous attacks could modify or delete data, or even invoke stored procedures.

>A2:2017-Broken Authentication    
- Scenario #1: Credential stuffing, the use of lists of known passwords, is a common attack. If an application does not implement automated threat or credential stuffing protections, the application can be used as a password oracle to determine if the credentials are valid.

- Scenario #2: Most authentication attacks occur due to the continued use of passwords as a sole factor. Once considered best practices, password rotation and complexity requirements are viewed as encouraging users to use, and reuse, weak passwords. Organizations are recommended to stop these practices per NIST 800-63 and use multi-factor authentication.

- Scenario #3: Application session timeouts aren't set properly. A user uses a public computer to access an application. Instead of selecting “logout” the user simply closes the browser tab and walks away. An attacker uses the same browser an hour later, and the user is still authenticated.
>A3:2017-Sensitive Data Exposure    
- Scenario #1: An application encrypts credit card numbers in a database using automatic database encryption. However, this data is automatically decrypted when retrieved, allowing an SQL injection flaw to retrieve credit card numbers in clear text. 

- Scenario #2: A site doesn't use or enforce TLS for all pages or supports weak encryption. An attacker monitors network traffic (e.g. at an insecure wireless network), downgrades connections from HTTPS to HTTP, intercepts requests, and steals the user's session cookie. The attacker then replays this cookie and hijacks the user's (authenticated) session, accessing or modifying the user's private data. Instead of the above they could alter all transported data, e.g. the recipient of a money transfer.

- Scenario #3: The password database uses unsalted or simple hashes to store everyone's passwords. A file upload flaw allows an attacker to retrieve the password database. All the unsalted hashes can be exposed with a rainbow table of pre-calculated hashes. Hashes generated by simple or fast hash functions may be cracked by GPUs, even if they were salted.
>A4:2017-XML External Entities (XXE)    
Numerous public XXE issues have been discovered, including attacking embedded devices. XXE occurs in a lot of unexpected places, including deeply nested dependencies. The easiest way is to upload a malicious XML file, if accepted:

- Scenario #1: The attacker attempts to extract data from the server:

        <?xml version="1.0" encoding="ISO-8859-1"?>
        <!DOCTYPE foo [
        <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
        <foo>&xxe;</foo>

- Scenario #2: An attacker probes the server's private network by changing the above ENTITY line to:

        <!ENTITY xxe SYSTEM "https://192.168.1.1/private" >]>
        
- Scenario #3: An attacker attempts a denial-of-service attack by including a potentially endless file:

        <!ENTITY xxe SYSTEM "file:///dev/random" >]>
        
>A5:2017-Broken Access Control 
- Scenario #1: The application uses unverified data in a SQL call that is accessing account information:

        pstmt.setString(1, request.getParameter("acct"));
        ResultSet results = pstmt.executeQuery( );
        
An attacker simply modifies the 'acct' parameter in the browser to send whatever account number they want. If not properly verified, the attacker can access any user's account.

        http://example.com/app/accountInfo?acct=notmyacct

- Scenario #2: An attacker simply force browses to target URLs. Admin rights are required for access to the admin page.

        http://example.com/app/getappInfo
        http://example.com/app/admin_getappInfo
        
If an unauthenticated user can access either page, it’s a flaw. If a non-admin can access the admin page, this is a flaw.
>A6:2017-Security Misconfiguration    

>A7:2017-Cross-Site Scripting (XSS)    
>A8:2017-Insecure Deserialization    
>A9:2017-Using Components with Known Vulnerabilities    
>A10:2017-Insufficient Logging&Monitoring    
